<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Restaurant Audit | Simplex</title>
    <link rel="stylesheet" href="/assets/restaurant_audit/css/audit-form.css">
</head>
<body>
    <div class="header">
        <div class="header-left">
             <button class="back-btn" onclick="goBack()">‚Üê Back</button>
            <div class="restaurant-info">
                <h1 id="restaurant-name">Loading...</h1>
            </div>
        </div>
        <button class="submit-btn" id="submit-btn" onclick="submitAudit()" disabled>Submit Audit</button>
    </div>

    <div class="container">
        <div id="loading" class="loading card">Loading Audit...</div>
        <div id="error" class="error card" style="display: none;"></div>
        
        <div id="audit-interface" style="display: none;">
            <div class="card location-check" id="location-check" style="margin-bottom: 1.5rem;">
                 <div class="location-status">
                    <div class="status-icon loading" id="location-icon">‚è≥</div>
                    <span id="location-text">Checking your location...</span>
                </div>
            </div>
            
            <div class="card dashboard">
                 <div class="progress-card">
                    <h3>Completion</h3>
                    <div class="progress-circle-container">
                        <svg class="progress-circle" width="120" height="120" viewBox="0 0 120 120"><circle class="progress-circle-bg" cx="60" cy="60" r="54"></circle><circle class="progress-circle-fg" id="completion-circle" cx="60" cy="60" r="54" pathLength="100" style="stroke-dasharray: 100; stroke-dashoffset: 100;"></circle></svg>
                        <div class="progress-text" id="completion-text">0%</div>
                    </div>
                </div>
                <div class="progress-card">
                    <h3>Audit Score</h3>
                    <div class="progress-circle-container">
                        <svg class="progress-circle" width="120" height="120" viewBox="0 0 120 120"><circle class="progress-circle-bg" cx="60" cy="60" r="54"></circle><circle class="progress-circle-fg" id="score-circle" cx="60" cy="60" r="54" pathLength="100" style="stroke-dasharray: 100; stroke-dashoffset: 100;"></circle></svg>
                        <div class="progress-text" id="score-text">0</div>
                    </div>
                </div>
            </div>
            
            <div class="main-layout">
                <div class="audit-sections card">
                    <h2>Audit Sections</h2>
                    <div class="category-grid" id="category-grid"></div>
                </div>
                <div class="overall-comment card">
                     <h2>Overall Comments</h2>
                     <textarea id="overall-comment" class="text-input" placeholder="Add any overall comments..." rows="4"></textarea>
                </div>
            </div>
        </div>
    </div>

    <div class="chat-modal" id="chat-modal">
        <div class="chat-container">
            <div class="chat-header">
                <h3 id="chat-title">Category Audit</h3>
                <button class="close-chat" id="close-chat">&times;</button>
            </div>
            <div class="chat-messages" id="chat-messages"></div>
            <div class="chat-input" id="chat-input">
                <div class="answer-options" id="answer-options"></div>
            </div>
        </div>
    </div>

    <script>
        // --- All of your JavaScript code remains here ---
        let currentRestaurant = null;
        let auditData = { categories: [], answers: {} };
        let totalQuestions = 0;
        const chatModal = document.getElementById('chat-modal');
        const chatMessages = document.getElementById('chat-messages');
        const answerOptions = document.getElementById('answer-options');
        let currentCategory = null;
        let questionQueue = [];
        let followUpQueue = [];
        let currentQuestion = null;

        document.addEventListener('DOMContentLoaded', initializeAuditForm);

        async function initializeAuditForm() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const restaurantId = urlParams.get('restaurant');
                if (!restaurantId) throw new Error('No restaurant selected.');
                const storedRestaurant = sessionStorage.getItem('selectedRestaurant');
                if (storedRestaurant) {
                    currentRestaurant = JSON.parse(storedRestaurant);
                    document.getElementById('restaurant-name').textContent = currentRestaurant.restaurant_name;
                }
                await checkUserLocation(restaurantId);
                await loadChecklistTemplate(restaurantId);
            } catch (error) {
                showError(error.message);
            }
        }

        async function loadChecklistTemplate(restaurantId) {
            const response = await fetch('/api/method/restaurant_audit.api.audit_api.get_checklist_template', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ restaurant_id: restaurantId })
            });
            if (!response.ok) throw new Error(`Server error: ${response.status}`);
            const result = await response.json();
            if (!result.message?.success) throw new Error(result.message?.message || 'Failed to load checklist.');
            const icons = ["üßº", "üç≥", "üòä", "üî•", "üìã", "üì¶", " hygiene", "temperature"];
            auditData.categories = result.message.templates.flatMap((template, tIndex) => 
                template.categories.map((cat, cIndex) => ({
                    id: cat.id,
                    name: cat.name,
                    icon: icons[(tIndex + cIndex) % icons.length],
                    questions: cat.questions.map(q => ({
                        id: q.id, text: q.text, type: q.answer_type,
                        is_mandatory: q.is_mandatory, allow_image_upload: q.allow_image_upload
                    })),
                    completed: false
                }))
            );
            totalQuestions = auditData.categories.reduce((acc, cat) => acc + cat.questions.length, 0);
            document.getElementById('loading').style.display = 'none';
            document.getElementById('audit-interface').style.display = 'block';
            renderCategoryGrid();
            updateDashboard();
        }

        function renderCategoryGrid() { const grid = document.getElementById('category-grid'); grid.innerHTML = ''; auditData.categories.forEach(cat => { const tag = document.createElement('div'); tag.className = `category-tag ${cat.completed ? 'completed' : ''}`; tag.dataset.categoryId = cat.id; tag.innerHTML = `<div class="icon">${cat.icon}</div><h4>${cat.name}</h4><div class="status">${cat.completed ? 'Complete' : 'Pending'}</div>`; grid.appendChild(tag); }); }
        function updateDashboard() { const answeredCount = Object.keys(auditData.answers).length; const completion = totalQuestions > 0 ? Math.round((answeredCount / totalQuestions) * 100) : 0; document.getElementById('completion-text').textContent = `${completion}%`; document.getElementById('completion-circle').style.strokeDashoffset = 100 - completion; let totalScore = 0; let maxScore = 0; Object.values(auditData.answers).forEach(ans => { maxScore += 5; totalScore += ans.score; }); const scorePercentage = maxScore > 0 ? Math.round((totalScore / maxScore) * 100) : 0; const scoreCircle = document.getElementById('score-circle'); document.getElementById('score-text').textContent = scorePercentage; scoreCircle.style.strokeDashoffset = 100 - scorePercentage; scoreCircle.style.stroke = scorePercentage < 50 ? 'var(--error-color)' : scorePercentage < 80 ? 'var(--star-color)' : 'var(--success-color)'; document.getElementById('submit-btn').disabled = completion < 100; }

        function openChat(categoryId) { currentCategory = auditData.categories.find(c => c.id === categoryId); if (!currentCategory) return; questionQueue = [...currentCategory.questions]; document.getElementById('chat-title').textContent = currentCategory.name + " Audit"; chatMessages.innerHTML = ''; chatModal.style.display = 'flex'; setTimeout(() => chatModal.classList.add('active'), 10); processNextInQueue(); }
        function closeChat() { const isCategoryComplete = currentCategory.questions.every(q => auditData.answers[q.id]); if(isCategoryComplete) currentCategory.completed = true; chatModal.classList.remove('active'); setTimeout(() => chatModal.style.display = 'none', 300); updateDashboard(); renderCategoryGrid(); }

        function processNextInQueue() {
            if (followUpQueue.length > 0) {
                const followUp = followUpQueue.shift();
                askFollowUpQuestion(followUp);
            } else if (questionQueue.length > 0) {
                const question = questionQueue.shift();
                if (auditData.answers[question.id]) { processNextInQueue(); return; }
                currentQuestion = question;
                askMainQuestion(question);
            } else {
                addMessage("Section complete! Great job.", "bot");
                setTimeout(closeChat, 1500);
            }
        }

        function askMainQuestion(question) { const indicator = showTypingIndicator(); setTimeout(() => { indicator.remove(); addMessage(question.text, "bot"); renderAnswerOptions(question); }, 1000); }
        function renderAnswerOptions(question) {
            answerOptions.innerHTML = '';
            let options = [];
            if (question.type === 'Yes/No') { options = [{ text: 'Yes', score: 5 }, { text: 'No', score: 1 }]; }
            else if (question.type === 'Rating') { options = [...Array(5)].map((_, i) => ({ text: '‚≠ê'.repeat(i + 1), score: i + 1 })); }
            else if (question.type === 'Text') { const textInput = document.createElement('textarea'); textInput.placeholder = "Type your answer and press Enter..."; textInput.className = "chat-textarea"; textInput.onkeydown = e => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleAnswer(question, { text: e.target.value, score: 0 }); } }; answerOptions.appendChild(textInput); textInput.focus(); return; }
            options.forEach(opt => { const btn = document.createElement('button'); btn.className = `answer-btn ${question.type === 'Rating' ? 'star-btn' : ''}`; btn.innerHTML = opt.text; btn.onclick = () => handleAnswer(question, opt); answerOptions.appendChild(btn); });
        }
        function handleAnswer(question, answer) { addMessage(answer.text, 'user'); auditData.answers[question.id] = { score: answer.score, value: answer.text, comment: "", image_data: "" }; answerOptions.innerHTML = ''; if (question.allow_image_upload) followUpQueue.push({ type: 'image', forQuestionId: question.id }); followUpQueue.push({ type: 'comment', forQuestionId: question.id }); processNextInQueue(); }
        
        function askFollowUpQuestion(followUp) {
            addMessage(followUp.type === 'image' ? "Would you like to add a photo?" : "Any comments for this question?", "bot");
            answerOptions.innerHTML = '';
            
            const container = document.createElement('div');
            container.className = 'follow-up-container';
            
            if (followUp.type === 'image') {
                const fileInput = document.createElement('input');
                fileInput.type = 'file'; fileInput.accept = 'image/*';
                fileInput.className = 'chat-file-input';
                fileInput.onchange = e => handleImageFollowUp(followUp, e.target.files[0]);
                container.appendChild(fileInput);
            } else {
                const textInput = document.createElement('textarea');
                textInput.placeholder = "Type comment and press Enter...";
                textInput.className = "chat-textarea";
                textInput.onkeydown = e => { if(e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleCommentFollowUp(followUp, e.target.value); }};
                container.appendChild(textInput);
                textInput.focus();
            }
            const skipBtn = document.createElement('button');
            skipBtn.className = 'answer-btn skip-btn';
            skipBtn.textContent = "Skip";
            skipBtn.onclick = () => { answerOptions.innerHTML = ''; processNextInQueue(); };
            container.appendChild(skipBtn);
            answerOptions.appendChild(container);
        }

        async function handleImageFollowUp(followUp, file) { if (!file) { processNextInQueue(); return; } addMessage("Image selected.", 'user'); auditData.answers[followUp.forQuestionId].image_data = await toBase64(file); answerOptions.innerHTML = ''; processNextInQueue(); }
        function handleCommentFollowUp(followUp, comment) { if (!comment) { processNextInQueue(); return; } addMessage(comment, 'user'); auditData.answers[followUp.forQuestionId].comment = comment; answerOptions.innerHTML = ''; processNextInQueue(); }
        
        function addMessage(text, sender) { const messageDiv = document.createElement('div'); messageDiv.className = `message ${sender}-message`; messageDiv.innerHTML = text; chatMessages.appendChild(messageDiv); chatMessages.scrollTop = chatMessages.scrollHeight; }
        function showTypingIndicator() { const indicator = document.createElement('div'); indicator.className = 'typing-indicator'; indicator.innerHTML = '<span></span><span></span><span></span>'; chatMessages.appendChild(indicator); chatMessages.scrollTop = chatMessages.scrollHeight; return indicator; }
        
        async function submitAudit() { const submitBtn = document.getElementById('submit-btn'); submitBtn.textContent = 'Submitting...'; submitBtn.disabled = true; try { const formattedAnswers = Object.entries(auditData.answers).map(([qid, ans]) => ({ question_id: qid, answer_value: ans.value, answer_comment: ans.comment, image_data: ans.image_data, category: auditData.categories.find(cat => cat.questions.some(q => q.id === qid))?.id })); const response = await fetch('/api/method/restaurant_audit.api.audit_api.submit_audit', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ restaurant_id: currentRestaurant.name, answers: JSON.stringify(formattedAnswers), overall_comment: document.getElementById('overall-comment').value }) }); if (!response.ok) throw new Error(`Submit failed with status: ${response.status}`); const result = await response.json(); if (!result.message?.success) throw new Error(result.message?.message || 'Failed to submit audit.'); alert('Audit submitted successfully!'); window.location.href = '/audit-restaurants'; } catch (error) { alert(`Error: ${error.message}`); submitBtn.textContent = 'Submit Audit'; submitBtn.disabled = false; } }
        function goBack() { window.location.href = '/audit-restaurants'; }
        function showError(message) { document.getElementById('loading').style.display = 'none'; const errorDiv = document.getElementById('error'); errorDiv.textContent = message; errorDiv.style.display = 'block'; }
        
        async function checkUserLocation(restaurantId) { const locationIcon = document.getElementById('location-icon'); const locationText = document.getElementById('location-text'); try { const position = await getCurrentPosition(); const { latitude, longitude } = position.coords; locationIcon.textContent = 'üìç'; locationText.textContent = 'Validating location...'; const response = await fetch('/api/method/restaurant_audit.api.audit_api.validate_location', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ restaurant_id: restaurantId, user_latitude: latitude, user_longitude: longitude }) }); if (!response.ok) throw new Error(`Server error: ${response.status}`); const result = await response.json(); if (result?.message?.success) { const validation = result.message; if (validation.is_within_range) { locationIcon.className = 'status-icon success'; locationIcon.textContent = '‚úì'; locationText.textContent = 'Location Verified'; } else { throw new Error(validation.message || 'You are not at the restaurant location.'); } } else { throw new Error(result?.message?.message || 'Location validation failed.'); } } catch (error) { console.error("Location check failed:", error); locationIcon.className = 'status-icon error'; locationIcon.textContent = '‚úó'; locationText.textContent = 'Location Check Failed'; } }
        function getCurrentPosition() { return new Promise((resolve, reject) => { if (!navigator.geolocation) return reject(new Error('Geolocation is not supported.')); navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }); }); }
        
        function toBase64(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.readAsDataURL(file); reader.onload = () => resolve(reader.result); reader.onerror = error => reject(error); }); }
        
        document.addEventListener('DOMContentLoaded', () => {
            initializeAuditForm();
            document.getElementById('category-grid').addEventListener('click', e => {
                const tag = e.target.closest('.category-tag');
                if (tag) openChat(tag.dataset.categoryId);
            });
            document.getElementById('close-chat').addEventListener('click', closeChat);
        });
    </script>
</body>
</html>